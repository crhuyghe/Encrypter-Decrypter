import contextlib
import tkinter as tk
import asyncio
from tkinter import ttk, filedialog as fd
from FlatButton import FlatButton
from ResizingText import ResizingText
import os
import random
from encryption.elliptic_curve import generateSharedSecret, generatePublicKey

import EncryptionManagement


class AsyncWindow(tk.Tk):
    """This is a special variation of the tkinter Tk object configured to run with asyncio functions"""
    tasks = set()  # Need to keep a reference to all running tasks

    def __init__(self, main_loop: asyncio.AbstractEventLoop):
        """The AsyncWindow class updates itself through a task on the asyncio event loop, so it must be initialized
        with a reference to it.
        :param main_loop:asyncio.AbstractEventLoop, the main event loop generated by asyncio.get_event_loop()"""
        tk.Tk.__init__(self)
        self.private = 0
        directory = __file__.replace("\\", "/")[:__file__.replace("\\", "/").rindex("/")]
        with open(f"{directory}/private_key.txt") as f:
            self.private = int(f.readline())
            f.close()
        # These lines are necessary for running asyncio with tkinter
        self._loop = main_loop  # Maintaining a reference to the loop that can be used within the class
        self.interval = 1 / 120  # The refresh rate of the window. 1/120 means 120 frames per second
        # The window will not close normally, so this line is needed to ensure that it can be terminated.
        self.protocol("WM_DELETE_WINDOW", lambda: self.run_as_task(self._close))
        self.run_as_task(self._updater)  # Starting the window update loop
        self._updater_closed = asyncio.Event()  # Flag for when the updater loop terminates successfully
        self._updater_running = asyncio.Event()  # Flag for freezing the update loop
        self._updater_running.set()
        self._closing = False  # General boolean to detect if the closing function is active

        self.title("Encrypter-Decrypter")
        self.state("zoomed")  # Fill the screen

        # Selecting a nice font for the interface
        ttk.Style().configure('.', font=('Segoe UI Symbol', 16), background="#24272b", foreground="#b6bfcc")
        ttk.Style().configure("border.TFrame", background="#969fac")

        self.file_to_encrypt = ""
        self.file_to_decrypt = ""

        # Initialize all the GUI elements
        self.main_frame = ttk.Frame(self)
        self.border = ttk.Frame(self.main_frame, style="border.TFrame", width=1)

        self.encrypter_frame = ttk.Frame(self.main_frame)

        self.encryption_label = ttk.Label(self.encrypter_frame, text="Encryption", font=("Segoe UI Bold", 30))
        self.encrypter_file_label = ttk.Label(self.encrypter_frame, text="Choose a file to encrypt", padding=10)
        self.encrypter_file_button = FlatButton(self.encrypter_frame, text="Open file", font=("Segoe UI", 12),
                                                command=self.select_unencrypted_file)

        self.encrypter_selected_file_text = tk.StringVar()
        self.encrypter_selected_file_label = ttk.Label(self.encrypter_frame,
                                                       textvariable=self.encrypter_selected_file_text)

        self.encrypter_loading_label = ttk.Label(self.encrypter_frame, text="Encrypting...", foreground="#24272b")

        self.encrypt_button = FlatButton(self.encrypter_frame, text="Encrypt", font=("Segoe UI", 12),
                                         command=lambda: self.run_as_task(self.encrypt))
        self.encrypter_key_label = ttk.Label(self.encrypter_frame,
                                             text="Input the recipient's public key for encryption")
        self.encrypter_key_field = ResizingText(self.encrypter_frame, dynamic=True, min_height=2,
                                                width=50, text_padding=10)
        self.encrypter_key_field.toggle_modification()

        self.copy_button = FlatButton(self.encrypter_frame, text="Copy This Instance's Public Key",
                                      font=("Segoe UI", 12), command=self._copy_key)

        self.encryption_label.grid(row=0, column=1, columnspan=3, pady=(40, 200))
        self.encrypter_file_label.grid(row=2, column=2)
        self.encrypter_file_button.grid(row=3, column=2)
        self.encrypter_selected_file_label.grid(row=4, column=2, pady=(0, 180))
        self.encrypter_loading_label.grid(row=5, column=2)
        self.encrypt_button.grid(row=6, column=2, pady=(0, 20))
        self.encrypter_key_label.grid(row=7, column=2)
        self.encrypter_key_field.grid(row=8, column=1, columnspan=3)
        self.copy_button.grid(row=9, column=2, pady=(20, 0))

        self.decrypter_frame = ttk.Frame(self.main_frame)

        self.decryption_label = ttk.Label(self.decrypter_frame, text="Decryption", font=("Segoe UI Bold", 30))
        self.decrypter_file_label = ttk.Label(self.decrypter_frame, text="Choose an encrypted file to decrypt",
                                              padding=10)
        self.decrypter_file_button = FlatButton(self.decrypter_frame, text="Open file", font=("Segoe UI", 12),
                                                command=self.select_encrypted_file)

        self.decrypter_selected_file_text = tk.StringVar()
        self.decrypter_selected_file_label = ttk.Label(self.decrypter_frame,
                                                       textvariable=self.decrypter_selected_file_text)

        self.decrypter_loading_label = ttk.Label(self.decrypter_frame, text="Decrypting...", foreground="#24272b")
        self.decrypt_button = FlatButton(self.decrypter_frame, text="Decrypt", font=("Segoe UI", 12),
                                         command=lambda: self.run_as_task(self.decrypt))
        self.decrypter_key_label = ttk.Label(self.decrypter_frame,
                                             text="Enter the public key used to encrypt the file")
        self.decrypter_key_field = ResizingText(self.decrypter_frame, dynamic=True, min_height=2,
                                                width=50, text_padding=10)
        self.decrypter_key_field.toggle_modification()

        self.decryption_label.grid(row=0, column=1, columnspan=3, pady=(40, 200))
        self.decrypter_file_label.grid(row=2, column=2)
        self.decrypter_file_button.grid(row=3, column=2)
        self.decrypter_selected_file_label.grid(row=4, column=2, pady=(0, 180))
        self.decrypter_loading_label.grid(row=5, column=2)
        self.decrypt_button.grid(row=6, column=2, pady=(0, 20))
        self.decrypter_key_label.grid(row=7, column=2)
        self.decrypter_key_field.grid(row=8, column=1, columnspan=3)

        # self.encrypter_frame.rowconfigure(0, weight=1)
        # self.encrypter_frame.rowconfigure(4, weight=1)
        self.encrypter_frame.columnconfigure(0, weight=1)
        self.encrypter_frame.columnconfigure(4, weight=1)
        # self.decrypter_frame.rowconfigure(0, weight=1)
        # self.decrypter_frame.rowconfigure(4, weight=1)
        self.decrypter_frame.columnconfigure(0, weight=1)
        self.decrypter_frame.columnconfigure(4, weight=1)
        self.main_frame.columnconfigure(0, weight=1)
        self.main_frame.columnconfigure(2, weight=1)
        self.main_frame.rowconfigure(0, weight=1)
        self.encrypter_frame.grid(row=0, column=0, sticky="nsew")
        self.border.grid(row=0, column=1, sticky="ns")
        self.decrypter_frame.grid(row=0, column=2, sticky="nsew")
        self.main_frame.pack(fill="both", expand=1)

    def select_unencrypted_file(self):
        """Selects a file for encryption"""
        file_name = fd.askopenfilename(filetypes=[('All Files', '*.*')])
        if len(file_name) > 0:
            self.encrypter_selected_file_text.set("Selected file: " + file_name[file_name.rindex("/") + 1:])
            self.file_to_encrypt = file_name

    def select_encrypted_file(self):
        """Selects a file for decryption"""
        file_name = fd.askopenfilename(filetypes=[('All Files', '*.*')])
        if len(file_name) > 0:
            self.decrypter_selected_file_text.set("Selected file: " + file_name[file_name.rindex("/") + 1:])
            self.file_to_decrypt = file_name

    async def encrypt(self):
        """Starts process of encrypting the selected file"""
        if self.file_to_encrypt != "":
            public = self.encrypter_key_field.get_text().split(" ")
            try:
                for i in range(len(public)):
                    public[i] = int(public[i])
                self.encrypter_loading_label.configure(foreground="#b6bfcc")
                shared_secret = generateSharedSecret(self.private, public)

                encrypted_string= await asyncio.to_thread(EncryptionManagement.encrypt_file,
                                                                self.file_to_encrypt,
                                                                hex(shared_secret[0])[2:].zfill(32))
                self.encrypter_loading_label.configure(foreground="#24272b")
            except Exception as e:
                print(e)
                return
            new_file_name = fd.asksaveasfilename(
                confirmoverwrite=True,
                filetypes=[('All Files', '*.*')],
                defaultextension=None,
                initialfile=self.file_to_encrypt[self.file_to_encrypt.rindex("/") + 1:],
                title="Save encrypted file",
            )
            if new_file_name != '':
                with open(new_file_name, "w") as nfile:
                    nfile.write(encrypted_string)

    async def decrypt(self):
        if self.file_to_decrypt != "":
            """Starts process of decrypting the selected file"""
            # These lines use an unimplemented function. Switch them to using the stuff in the encryption folder.
            public = self.decrypter_key_field.get_text().split(" ")
            try:
                for i in range(len(public)):
                    public[i] = int(public[i])
                self.decrypter_loading_label.configure(foreground="#b6bfcc")
                shared_secret = generateSharedSecret(self.private, public)
                decrypted_binary_string = await asyncio.to_thread(EncryptionManagement.decrypt_file,
                                                                  self.file_to_decrypt,
                                                                  hex(shared_secret[0])[2:].zfill(32))
                self.decrypter_loading_label.configure(foreground="#24272b")
            except Exception as e:
                print(e)
                return
            new_file_name = fd.asksaveasfilename(
                confirmoverwrite=True,
                filetypes=[('All Files', '*.*')],
                initialfile=self.file_to_decrypt[self.file_to_decrypt.rindex("/") + 1:],
                title="Save encrypted file",
            )
            if new_file_name != '':
                with open(new_file_name, "wb") as nfile:
                    nfile.write(decrypted_binary_string)

    def _copy_key(self):
        key = generatePublicKey(self.private)
        self.clipboard_clear()
        self.clipboard_append(key)  # Put the public key here

    def clear_window(self, destroy=True, grid=True):
        """Clears the visible window of all widgets. Destroys the widgets if specified.
        :param destroy:bool, whether to destroy cleared widgets
        :param grid:bool, whether the grid manager is in use"""
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=0)
        if destroy:
            for widget in self.winfo_children():
                widget.destroy()
        else:
            for widget in self.winfo_children():
                if grid:
                    widget.grid_forget()
                else:
                    widget.pack_forget()

    def run_as_task(self, func, *args):
        """Takes an asynchronous function and schedules it to execute within the event loop.
        Scheduled tasks will not complete in any specific order.
        Format: self.run_as_task(coroutine, arg1, arg2, ..., argN)"""
        task = self._loop.create_task(func(*args))  # Schedule execution of a coroutine
        self.tasks.add(task)  # Create a reference to new tasks
        task.add_done_callback(self.tasks.discard)  # Clear task reference after completion

    def freeze_updater(self):
        """Prevents the screen from updating.
        Note: Do not freeze for long intervals"""
        self._updater_running.clear()

    def unfreeze_updater(self):
        """Allows the screen to begin updating after having been frozen.
        Note: Do not freeze for long intervals"""
        self._updater_running.set()

    async def _updater(self):
        """Updates the GUI"""
        while not self._closing:
            await self._updater_running.wait()
            self.update()
            await asyncio.sleep(self.interval)
        self._updater_closed.set()

    async def _close(self):
        """Allows the window to close properly"""
        self._closing = True
        try:
            self._updater_running.set()
            await asyncio.wait_for(self._updater_closed.wait(), 2)
        except asyncio.TimeoutError as e:
            print(e)
        for task in self.tasks:
            with contextlib.suppress(asyncio.CancelledError):
                if task and "AsyncGUI._close" not in str(task.get_coro()):
                    task.cancel(msg=None)
        self._loop.stop()
        self.destroy()
