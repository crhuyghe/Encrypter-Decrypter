import contextlib
import tkinter as tk
import asyncio
from tkinter import ttk, filedialog as fd
from FlatButton import FlatButton
from ResizingText import ResizingText

import EncryptionManagement

class AsyncWindow(tk.Tk):
    """This is a special variation of the tkinter Tk object configured to run with asyncio functions"""
    tasks = set()  # Need to keep a reference to all running tasks

    def __init__(self, main_loop: asyncio.AbstractEventLoop):
        """The AsyncWindow class updates itself through a task on the asyncio event loop, so it must be initialized
        with a reference to it.
        :param main_loop:asyncio.AbstractEventLoop, the main event loop generated by asyncio.get_event_loop()"""
        tk.Tk.__init__(self)

        # These lines are necessary for running asyncio with tkinter
        self._loop = main_loop  # Maintaining a reference to the loop that can be used within the class
        self.interval = 1 / 120  # The refresh rate of the window. 1/120 means 120 frames per second
        # The window will not close normally, so this line is needed to ensure that it can be terminated.
        self.protocol("WM_DELETE_WINDOW", lambda: self.run_as_task(self._close))
        self.run_as_task(self._updater)  # Starting the window update loop
        self._updater_closed = asyncio.Event()  # Flag for when the updater loop terminates successfully
        self._updater_running = asyncio.Event()  # Flag for freezing the update loop
        self._updater_running.set()
        self._closing = False  # General boolean to detect if the closing function is active

        self.title("Encrypter-Decrypter")
        self.state("zoomed")  # Fill the screen

        # Selecting a nice font for the interface
        ttk.Style().configure('.', font=('Segoe UI Symbol', 16), background="#24272b", foreground="#b6bfcc")
        ttk.Style().configure("border.TFrame", background="#969fac")

        self.file_to_encrypt = ""
        self.file_to_decrypt = ""

        # Initialize all the GUI elements
        self.main_frame = ttk.Frame(self)
        self.border = ttk.Frame(self.main_frame, style="border.TFrame", width=1)

        self.encrypter_frame = ttk.Frame(self.main_frame)

        self.encryption_label = ttk.Label(self.encrypter_frame, text="Encryption", font=("Segoe UI Bold", 30))
        self.encrypter_file_label = ttk.Label(self.encrypter_frame, text="Choose a file to encrypt", padding=10)
        self.encrypter_file_button = FlatButton(self.encrypter_frame, text="Open file", font=("Segoe UI", 12),
                                                command=self.select_unencrypted_file)

        self.encrypt_button = FlatButton(self.encrypter_frame, text="Encrypt", font=("Segoe UI", 12),
                                         command=lambda: self.run_as_task(self.encrypt))
        self.encrypter_key_label = ttk.Label(self.encrypter_frame,
                                             text="Input the recipient's public key for encryption")
        self.encrypter_key_field = ResizingText(self.encrypter_frame, dynamic=True, min_height=5,
                                                width=50, text_padding=10)
        self.encrypter_key_field.toggle_modification()

        self.encryption_label.grid(row=0, column=1, columnspan=3, pady=(40, 200))
        self.encrypter_file_label.grid(row=2, column=2)
        self.encrypter_file_button.grid(row=3, column=2, pady=(0, 200))
        self.encrypt_button.grid(row=4, column=2, pady=(0, 20))
        self.encrypter_key_label.grid(row=5, column=2)
        self.encrypter_key_field.grid(row=6, column=1, columnspan=3)

        self.decrypter_frame = ttk.Frame(self.main_frame)

        self.decryption_label = ttk.Label(self.decrypter_frame, text="Decryption", font=("Segoe UI Bold", 30))
        self.decrypter_file_label = ttk.Label(self.decrypter_frame, text="Choose a encrypted file to decrypt",
                                              padding=10)
        self.decrypter_file_button = FlatButton(self.decrypter_frame, text="Open file", font=("Segoe UI", 12),
                                                command=self.select_encrypted_file)

        self.decrypt_button = FlatButton(self.decrypter_frame, text="Decrypt", font=("Segoe UI", 12),
                                         command=lambda: self.run_as_task(self.decrypt))
        self.decrypter_key_label = ttk.Label(self.decrypter_frame,
                                             text="Use this public key to encrypt for this instance")
        self.decrypter_key_field = ResizingText(self.decrypter_frame, dynamic=True, min_height=5, width=50,
                                                text_padding=10, alt_color=True)

        self.decryption_label.grid(row=0, column=1, columnspan=3, pady=(40, 200))
        self.decrypter_file_label.grid(row=2, column=2)
        self.decrypter_file_button.grid(row=3, column=2, pady=(0, 200))
        self.decrypt_button.grid(row=4, column=2, pady=(0, 20))
        self.decrypter_key_label.grid(row=5, column=2)
        self.decrypter_key_field.grid(row=6, column=1, columnspan=3)

        # self.encrypter_frame.rowconfigure(0, weight=1)
        # self.encrypter_frame.rowconfigure(4, weight=1)
        self.encrypter_frame.columnconfigure(0, weight=1)
        self.encrypter_frame.columnconfigure(4, weight=1)
        # self.decrypter_frame.rowconfigure(0, weight=1)
        # self.decrypter_frame.rowconfigure(4, weight=1)
        self.decrypter_frame.columnconfigure(0, weight=1)
        self.decrypter_frame.columnconfigure(4, weight=1)
        self.main_frame.columnconfigure(0, weight=1)
        self.main_frame.columnconfigure(2, weight=1)
        self.main_frame.rowconfigure(0, weight=1)
        self.encrypter_frame.grid(row=0, column=0, sticky="nsew")
        self.border.grid(row=0, column=1, sticky="ns")
        self.decrypter_frame.grid(row=0, column=2, sticky="nsew")
        self.main_frame.pack(fill="both", expand=1)

    def select_unencrypted_file(self):
        """Selects a file for encryption"""
        file_name = fd.askopenfilename(filetypes=[('All Files', '*.*')])
        if len(file_name) > 0:
            self.file_to_encrypt = file_name

    def select_encrypted_file(self):
        """Selects a file for decryption"""
        file_name = fd.askopenfilename(filetypes=[('All Files', '*.*')])
        if len(file_name) > 0:
            self.file_to_decrypt = file_name


    async def encrypt(self):
        """Starts process of encrypting the selected file"""
        new_file_name = fd.asksaveasfilename(
            confirmoverwrite=True,
            filetypes=[('All Files', '*.*')],
            defaultextension=None,
            title="Save encrypted file",
        )
        if new_file_name != '':
            # These lines use an unimplemented function. Switch them to using the stuff in the encryption folder.
            encrypted_string, key = await asyncio.to_thread(EncryptionManagement.encrypt_file, self.file_to_encrypt)
            self.encrypter_key_field.change_text(key)
            with open(new_file_name, "w") as nfile:
                nfile.write(encrypted_string)

    async def decrypt(self):
        """Starts process of decrypting the selected file"""
        # These lines use an unimplemented function. Switch them to using the stuff in the encryption folder.
        decrypted_binary_string, name = await asyncio.to_thread(EncryptionManagement.decrypt_file,
                                                                self.file_to_decrypt,
                                                                self.decrypter_key_field.get_text())
        new_file_name = fd.asksaveasfilename(
            confirmoverwrite=True,
            filetypes=[('All Files', '*.*')],
            initialfile=name,
            title="Save encrypted file",
        )
        if new_file_name != '':
            with open(new_file_name, "wb") as nfile:
                nfile.write(decrypted_binary_string)

    def clear_window(self, destroy=True, grid=True):
        """Clears the visible window of all widgets. Destroys the widgets if specified.
        :param destroy:bool, whether to destroy cleared widgets
        :param grid:bool, whether the grid manager is in use"""
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=0)
        if destroy:
            for widget in self.winfo_children():
                widget.destroy()
        else:
            for widget in self.winfo_children():
                if grid:
                    widget.grid_forget()
                else:
                    widget.pack_forget()

    def run_as_task(self, func, *args):
        """Takes an asynchronous function and schedules it to execute within the event loop.
        Scheduled tasks will not complete in any specific order.
        Format: self.run_as_task(coroutine, arg1, arg2, ..., argN)"""
        task = self._loop.create_task(func(*args))  # Schedule execution of a coroutine
        self.tasks.add(task)  # Create a reference to new tasks
        task.add_done_callback(self.tasks.discard)  # Clear task reference after completion

    def freeze_updater(self):
        """Prevents the screen from updating.
        Note: Do not freeze for long intervals"""
        self._updater_running.clear()

    def unfreeze_updater(self):
        """Allows the screen to begin updating after having been frozen.
        Note: Do not freeze for long intervals"""
        self._updater_running.set()

    async def _updater(self):
        """Updates the GUI"""
        while not self._closing:
            await self._updater_running.wait()
            self.update()
            await asyncio.sleep(self.interval)
        self._updater_closed.set()

    async def _close(self):
        """Allows the window to close properly"""
        self._closing = True
        try:
            self._updater_running.set()
            await asyncio.wait_for(self._updater_closed.wait(), 2)
        except asyncio.TimeoutError as e:
            print(e)
        for task in self.tasks:
            with contextlib.suppress(asyncio.CancelledError):
                if task and "AsyncGUI._close" not in str(task.get_coro()):
                    task.cancel(msg=None)
        self._loop.stop()
        self.destroy()


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    app = AsyncWindow(loop)
    loop.run_forever()
    loop.close()
